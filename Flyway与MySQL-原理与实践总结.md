# Flyway 与 MySQL：原理与实践总结

本文用于解释：项目里引入 Flyway 之后，它和 MySQL 的关系是什么、数据是怎么“关联”的、为什么要连用，以及在真实开发中的实践价值。

## 1. Flyway 存储的到底是什么

Flyway **不存业务数据**。它主要存的是“数据库结构变更的版本历史”。

- 业务表（例如 `sys_user`、`base_product`）依然是 **MySQL 的普通表**，不属于 Flyway。
- Flyway 会在目标数据库中创建/使用一个历史表：`flyway_schema_history`。
  - 这个表记录每次迁移的元数据：版本号（V1/V2/V3/V4）、脚本名、checksum、执行时间、是否成功等。

你可以把 Flyway 理解为“数据库结构的 Git 提交记录”，而不是数据库本身。

## 2. Flyway 的 SQL 文件如何作用到 MySQL

Flyway 的迁移脚本通常以文件形式放在项目中（默认位置：`classpath:db/migration`），例如：

- `V1__init.sql`
- `V2__profile_menu.sql`
- `V3__system_user_role_pages.sql`
- `V4__base_data.sql`

Spring Boot 启动后会：

1) 根据 `spring.datasource.*` 建立到 MySQL 的 JDBC 连接  
2) Flyway 读取 `db/migration` 下的 SQL 文件  
3) 使用同一个 JDBC 连接，将脚本内 SQL **逐条执行到 MySQL**  
4) 执行成功后，在 `flyway_schema_history` 插入一条记录，标记对应版本已应用（下次不再重复执行）

## 3. Flyway 与 MySQL “关联”的本质是什么

本质只有两点：

- **同一个数据库连接（JDBC）**：Flyway 用你的 datasource 连接到 MySQL。
- **一个历史表（`flyway_schema_history`）**：用来判断“当前数据库处于哪个版本”、“哪些迁移已执行”。

Flyway 不需要 MySQL 的特殊功能；只要 MySQL 能执行 SQL、能创建表即可。

## 4. 为什么不能只用 MySQL？连用有什么好处

只用 MySQL 手工建表当然可以，但工程上会遇到这些典型问题：

- 环境不一致：开发/测试/生产数据库结构经常“有人忘了执行某个 SQL”导致差异
- 不可追踪：上线后发现缺字段/索引，不知道是哪次改动引入的
- 协作困难：多人并行改表，容易互相覆盖、漏改、执行顺序混乱
- 自动化部署困难：CI/CD 难以可靠地把数据库升级到“与当前代码匹配”的结构

Flyway 连用带来的收益：

- **版本可追踪**：一条 SQL 对应一个版本记录，可快速定位当前库版本
- **自动化一致性**：新环境/新同事拉代码启动即可迁移到正确结构
- **可重复部署**：部署流程可控，不依赖手工执行脚本
- **变更审计**：通过脚本名 + checksum 可以定位变更内容与来源
- **协作友好**：按版本追加迁移脚本，降低多人改表冲突

## 5. 对应的真实开发实践场景

Flyway 特别适合以下场景（也是大部分生产项目都会遇到的）：

- 多环境（dev/test/prod）需要保证数据库结构一致
- 团队协作频繁改表：新增字段、加索引、修复历史数据、初始化字典数据
- CI/CD 自动部署：发布时自动把数据库升级到匹配当前版本代码的结构
- 线上问题回溯：能快速定位“数据库结构/初始化数据”发生变化的版本点

## 6. 一句话总结

- **MySQL**：负责存储业务数据与执行 SQL
- **Flyway**：负责管理“数据库结构与初始化数据”的版本演进，并把执行记录存到 MySQL 的 `flyway_schema_history` 中

两者连用，让数据库变更像代码一样：可追踪、可自动化、可重复、可协作。

